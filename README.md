# 품질관리시스템 (Quality Management System, QMS)
[👉 서비스 바로가기](https://qms.jaemin.app)

**테스트 계정**
* 관리자(MG): 아이디 `test` / 비밀번호 `test12#$`
* 개발자(DEV): 아이디 `devtest` / 비밀번호 `devtest12#$`

---

## 🛠️ 기술 스택
Java, Spring Boot, Gradle, React, MySQL, Docker, AWS EC2, Nginx, GitHub Actions

---

## 1. 프로젝트 개요
JSP 기반 레거시 시스템을 React SPA로 전환하여, QA팀과 고객사가 결함을 쉽게 등록하고 개발자가 빠르게 대응할 수 있도록 개선했습니다.
* **개발 기간:** 2025.05 ~ 2025.09

---

## 2. 주요 기능
* **권한 및 사용자 관리**: 역할 기반 접근 제어 및 관리자 전용 사용자 관리
* **결함 관리**: 결함 등록/수정/상태 변경, 다중 파일 첨부, 처리 이력 관리
* **동적 검색**: QueryDSL 기반 다중 조건 검색
* **데이터 시각화**: ApexCharts 기반 결함 통계 대시보드

---

## 3. 핵심 개선 사항

### 🔒 인증 방식 변경

#### [도입 배경]
- 기존 시스템은 **세션 기반 인증**을 사용하여, 세션 ID 탈취 시 계정이 노출될 위험이 있고 CSRF 공격에 취약했습니다.
- 서버 재시작 시 모든 사용자가 재로그인해야 하는 불편함과, QA팀과 고객사가 동시에 사용하는 환경에서 발생하는 세션 충돌 및 예기치 못한 로그아웃 문제로 인해, 보다 안전하고 사용자 친화적인 인증 방식 도입이 필요했습니다.

#### **[해결 방안]**
- **JWT(JSON Web Token) 기반 Stateless 인증**을 도입하여 서버에 상태를 저장하지 않는 구조로 전환했습니다.
- 토큰을 **HTTPOnly + SameSite 쿠키**에 저장하여 JavaScript 접근을 차단하고, **XSS/CSRF 공격으로부터 안전하게 보호**했습니다.
- **Access Token(30분) + Refresh Token(3일)** 구조를 적용하여, 보안성과 사용성을 동시에 확보했습니다.

#### **[성과]**
- 세션 탈취 공격에 대한 **보안성이 크게 향상**되었고, **다중 서버 환경에서도 일관된 인증 상태**를 유지할 수 있게 되었습니다.
- 서버 재시작이나 배포 상황에서도 사용자가 **재로그인 없이 서비스를 지속**할 수 있어, **사용자 경험이 크게 개선**되었습니다.

---

### 🚀 무중단 배포

#### [도입 배경]
- 기존 배포는 수동으로 진행되어 애플리케이션을 재시작해야 했고, **배포 시마다 평균 3~5분의 서비스 중단**이 발생했습니다.
- 사용자가 작업 중일 경우 배포를 진행할 수 없어, **배포 시간을 별도로 조율**해야 하는 불편함이 있었습니다.
- 수동 배포 과정에서는 환경 설정 오류나 실행 실수 등 **휴먼 에러 가능성**이 높았습니다.

#### **[해결 방안]**
- **GitHub Actions**를 활용하여 빌드와 배포를 자동화하는 **CI/CD 파이프라인**을 구축했습니다.
- **Nginx 리버스 프록시 포트 스위칭** 기반 블루-그린 배포 전략을 구현하여, 새 버전이 완전히 준비된 후 트래픽을 전환하도록 했습니다.
- **Health Check (Spring Boot Actuator)**를 구현하여 새 버전이 정상 동작할 때만 트래픽 전환이 이루어지도록 안전장치를 마련했습니다.

#### **[성과]**
- **서비스 중단 없이** 사용자들이 시스템을 이용할 수 있게 되었습니다.
- 배포 과정이 **완전히 자동화**되어 휴먼 에러 가능성을 제거했습니다.
- QA팀과 고객사의 업무 연속성이 보장되어, **긴급 수정 사항을 즉시 반영할 수 있는 민첩한 개발 환경**을 구축했습니다.

---

### 💻 데이터 액세스 계층 개선 (MyBatis → JPA + QueryDSL)

#### [도입 배경]
- 기존 시스템은 **MyBatis** 기반으로 SQL 중심 개발이 이루어져, 비즈니스 로직이 Service 계층과 XML 파일에 분산되어 있었습니다.
- 정적 검색 조건만 지원하며, 복잡한 다중 조건 검색 시 불필요한 조건까지 포함되는 **비효율적인 쿼리**로 성능 저하가 발생했습니다.
- SQL과 Java 코드가 분리되어 있어, **쿼리 수정 시 관련 Java 코드까지 함께 점검해야 하는 불편함**이 있었습니다.

#### **[해결 방안]**
- **JPA**를 도입하여 객체 중심 개발을 가능하게 하고, 엔티티 내부에 비즈니스 로직을 배치하여 **응집도를 높였습니다.**
- **연관관계 매핑, 지연 로딩, 영속성 컨텍스트**를 활용하여 불필요한 쿼리 호출을 최소화했습니다.
- 복잡한 동적 쿼리가 필요한 검색 기능에는 **QueryDSL**을 적용하여, 컴파일 시 필드 타입과 존재 여부를 검증하고, 사용자가 입력한 조건에 따라 필요한 쿼리만 동적으로 생성하도록 구현했습니다.

#### **[성과]**
- 엔티티 내부로 비즈니스 로직이 모여 **코드가 직관적이고 이해하기 쉬워졌으며 유지보수성이 향상**되었습니다.
- 객체 중심 개발을 통해 **복잡한 도메인 로직을 체계적으로 관리**할 수 있게 되었고, 단위 테스트 작성도 용이해졌습니다.
- 동적 쿼리 적용으로 **검색 성능이 개선**되어, 사용자가 다양한 조건으로 빠르게 원하는 데이터를 조회할 수 있게 되었습니다.
